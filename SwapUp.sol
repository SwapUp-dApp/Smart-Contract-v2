// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

/*
 This smart contract has been written for an NFT swap dapp. The swap method recieves 3 params viz. message i.e. the swap metadata containing info
 about the user who made the swap offer and the user to whom the offer is made and the NFTs to be traded between them, signature i.e. a
 digital signature generated by hashing the swap metadata with the offeror's pvk, and lastly sender i.e. the offeror's wallet address. First of all the funtcion
 recreates the digital sign using the offeror's wallet address and encoded metadata. Then it compares the newly generated signature with the
 one passed as an argument. If the signatures match the contract proceeds towards transferring NFTs otherwise an error event is generated.
 This is essentially a security mechanism which ensures that any random caller may not be able to create a fake swap request.
 During the transfer phase another security check is employed to ensure that the caller is acceptor of the offer by decoding the metadata
 to attain the acceptor's address and then comparing it with the caller's address. Once, this check is passed the swap is inititaed and
 the gas fee is bore by the acceptor alone since they're the caller. Lastly, if any of the transfers fail all previous transfers are reverted
 and the swap is aborted.
*/

contract SwapUp is EIP712 {
  constructor() EIP712("swap up","1.0") {}

  function swap(
    address sender,
    bytes memory message,
    bytes memory signature
  ) external {
    string memory data;
    // decoding metadata
    (bytes[] memory tradeData) = abi.decode(message,(bytes[]));
    (bytes[] memory initNfts, string memory initAddress, address addrInit) = abi.decode(tradeData[0],(bytes[],string,address));
    (bytes[] memory acceptNfts, string memory acceptAddress, address addrAccept) = abi.decode(tradeData[1],(bytes[],string,address));
    data=initAddress;
    data=string.concat(data," offering to swap NFTs, ");
    data=string.concat(data,ParseStr(initNfts));
    data=string.concat(data," with the NFTs, ");
    data=string.concat(data,ParseStr(acceptNfts));
    data=string.concat(data," belonging to ");
    data=string.concat(data,acceptAddress);
    // regenerating sign hash
    bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
      keccak256("set(address sender,string msg)"),
      sender,
      keccak256(bytes(data))
    )));
    // verifying sign
    address signer = ECDSA.recover(digest, signature);
    require(signer == sender, "MyFunction: invalid signature");
    require(signer != address(0), "ECDSA: invalid signature");
    // checking if the caller is acceptor
    require(addrAccept == msg.sender, "caller is not acceptor!");
    // transferring NFTs
    transfer(initNfts, addrInit, addrAccept);
    transfer(acceptNfts, addrAccept, addrInit);
  }

  function transfer(bytes[] memory nfts,address sender,address receiver) internal {
    for (uint i = 0; i < nfts.length; i++) {
      (string memory tkn, address addrTkn, uint id, uint chain) = abi.decode(nfts[i],(string,address,uint,uint));
        if (chain==721) {
          IERC721(addrTkn).safeTransferFrom(sender,receiver,id);
        } else {
          IERC1155(addrTkn).safeTransferFrom(sender,receiver,id,1,"");
        }
    }
  }

  function ParseStr(bytes[] memory nfts) internal pure returns (string memory){
      string memory tokens="";
      for (uint i = 0; i < nfts.length; i++) {
      (string memory tkn, address addrTkn, uint id, uint chain) = abi.decode(nfts[i],(string,address,uint,uint));
      tokens=string.concat(tokens,"[id: ");
      tokens=string.concat(tokens,Strings.toString(id));
      tokens=string.concat(tokens,", type: ");
      tokens=string.concat(tokens,Strings.toString(chain));
      tokens=string.concat(tokens,", contract address: ");
      tokens=string.concat(tokens,tkn);
      tokens=string.concat(tokens,"]");
      if(i!=nfts.length-1){
        tokens=string.concat(tokens,",");
      }
    }
    return tokens;
  }
}