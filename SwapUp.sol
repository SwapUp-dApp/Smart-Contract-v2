// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";

/*
 This smart contract has been written for an NFT swap dapp. The swap method recieves 3 params viz. message i.e. the swap metadata containing info
 about the user who made the swap offer and the user to whom the offer is made and the NFTs to be traded between them, signature i.e. a
 digital signature generated by hashing the swap metadata with the offeror's pvk, and lastly sender i.e. the offeror's wallet address. First of all the funtcion
 recreates the digital sign using the offeror's wallet address and encoded metadata. Then it compares the newly generated signature with the
 one passed as an argument. If the signatures match the contract proceeds towards transferring NFTs otherwise an error event is generated.
 This is essentially a security mechanism which ensures that any random caller may not be able to create a fake swap request.
 During the transfer phase another security check is employed to ensure that the caller is acceptor of the offer by decoding the metadata
 to attain the acceptor's address and then comparing it with the caller's address. Once, this check is passed the swap is inititaed and
 the gas fee is bore by the acceptor alone since they're the caller. Lastly, if any of the transfers fail all previous transfers are reverted
 and the swap is aborted.
*/

contract SwapUp is EIP712 {
  constructor() EIP712("swap up","1.0") {}

  function swap(
    address sender,
    bytes memory message,
    bytes memory signature
  ) external {
    // regenerating sign hash
    bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
      keccak256("set(address sender,bytes msg)"),
      sender,
      keccak256(abi.encodePacked(message))
    )));
    // verifying sign
    address signer = ECDSA.recover(digest, signature);
    require(signer == sender, "signTypedDataV4: invalid signature");
    require(signer != address(0), "ECDSA: invalid signature");
    // NFT trade
    (bytes[] memory tradeData) = abi.decode(message,(bytes[]));
    (bytes[] memory initNfts, address initAddress) = abi.decode(tradeData[0],(bytes[],address));
    (bytes[] memory acceptNfts, address acceptAddress) = abi.decode(tradeData[1],(bytes[],address));
    // checking if the caller is acceptor
    require(acceptAddress == msg.sender, "caller is not acceptor!");
    for (uint i = 0; i < initNfts.length; i++) {
      (address tkn, uint id, uint chain) = abi.decode(initNfts[i],(address,uint,uint));
        if (chain==721) {
          IERC721(tkn).safeTransferFrom(initAddress,acceptAddress,id);
        } else {
          IERC1155(tkn).safeTransferFrom(initAddress,acceptAddress,id,1,"");
        }
    }
    for (uint i = 0; i < acceptNfts.length; i++) {
      (address tkn, uint id, uint chain) = abi.decode(acceptNfts[i],(address,uint,uint));
        if (chain==721) {
          IERC721(tkn).safeTransferFrom(acceptAddress,initAddress,id);
        } else {
          IERC1155(tkn).safeTransferFrom(acceptAddress,initAddress,id,1,"");
        }
    }
  }
}